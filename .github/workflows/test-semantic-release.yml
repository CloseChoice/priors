name: Test Semantic Release

on:
  push:
    branches:
      - 'feat/**'
      - 'ci/**'
  workflow_dispatch:
    inputs:
      publish_to_testpypi:
        description: 'Publish to TestPyPI?'
        required: true
        type: boolean
        default: false

permissions:
  contents: write
  issues: write
  pull-requests: write
  checks: write

jobs:
  commitlint:
    name: Validate Commits
    permissions:
      contents: read
      pull-requests: read
    uses: ./.github/workflows/commitlint.yml

  tests:
    name: Run Tests
    permissions:
      contents: read
      pull-requests: write
      checks: write
    uses: ./.github/workflows/tests.yml

  linting:
    name: Run Linting
    permissions:
      checks: write
      contents: write
    uses: ./.github/workflows/linting.yml

  semantic-release:
    name: Semantic Release (Test)
    needs: [commitlint, tests, linting]
    runs-on: ubuntu-latest
    outputs:
      new-release-published: ${{ steps.semantic.outputs.new-release-published }}
      new-release-version: ${{ steps.semantic.outputs.new-release-version }}
    steps:
      - name: Check out Git repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          persist-credentials: false

      - name: Set up Node.js
        uses: actions/setup-node@v4
        with:
          node-version: "lts/*"

      - name: Install semantic-release
        run: |
          npm install semantic-release@latest
          npm install @semantic-release/commit-analyzer
          npm install @semantic-release/release-notes-generator
          npm install @semantic-release/git
          npm install @semantic-release/changelog
          npm install @semantic-release/exec

      - name: Run semantic-release
        id: semantic
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          # Use the test config directly
          mv .releaserc.test.json .releaserc.json

          # Check if this is a manual trigger with TestPyPI publish enabled
          if [[ "${{ github.event_name }}" == "workflow_dispatch" && "${{ github.event.inputs.publish_to_testpypi }}" == "true" ]]; then
            echo "üîß Manual TestPyPI publish: Let semantic-release calculate next version"

            # Run semantic-release in dry-run to calculate next version
            OUTPUT=$(npx semantic-release 2>&1 || true)
            echo "$OUTPUT"

            # Parse the next version from semantic-release output
            NEXT_VERSION=$(echo "$OUTPUT" | grep -oP 'The next release version is \K[0-9]+\.[0-9]+\.[0-9]+' || true)

            if [ -n "$NEXT_VERSION" ]; then
              echo "üìà Next release version calculated by semantic-release: $NEXT_VERSION"
            else
              # No releasable commits, use current version
              NEXT_VERSION=$(grep "^version = " priors/pyproject.toml | sed 's/version = "\(.*\)"/\1/')
              echo "‚ÑπÔ∏è No releasable commits, using current version: $NEXT_VERSION"
            fi

            # Query TestPyPI API for existing dev versions
            echo "üîç Checking TestPyPI for existing dev versions of ${NEXT_VERSION}..."
            HIGHEST_DEV=$(python3 get_next_dev_version.py "${NEXT_VERSION}")

            # Increment dev number
            DEV_NUMBER=$((HIGHEST_DEV + 1))
            echo "üî¢ Next dev number for ${NEXT_VERSION}: ${DEV_NUMBER}"

            # Append dev suffix with incremented number
            TEST_VERSION_BASE="${NEXT_VERSION}-dev.${DEV_NUMBER}"

            # Convert to PEP 440 format for Python (0.1.1-dev.45 -> 0.1.1.dev45)
            PYTHON_VERSION=$(python3 convert_version.py "$TEST_VERSION_BASE" pep440)
            # Keep SemVer format for Rust
            RUST_VERSION=$(python3 convert_version.py "$TEST_VERSION_BASE" semver)

            echo "$PYTHON_VERSION" > .next-version-python
            echo "$RUST_VERSION" > .next-version-rust
            echo "‚úÖ Dev versions created for TestPyPI:"
            echo "  Python (PEP 440): $PYTHON_VERSION"
            echo "  Rust (SemVer): $RUST_VERSION"
            echo "new-release-version=$RUST_VERSION" >> $GITHUB_OUTPUT
            echo "new-release-published=true" >> $GITHUB_OUTPUT
          else
            # Normal push: just run semantic-release
            OUTPUT=$(npx semantic-release 2>&1 || true)
            echo "$OUTPUT"

            # Check if version files were created
            if [ -f .next-version-python ] && [ -f .next-version-rust ]; then
              PYTHON_VERSION=$(cat .next-version-python)
              RUST_VERSION=$(cat .next-version-rust)
              echo "‚úÖ New versions created:"
              echo "  Python: $PYTHON_VERSION"
              echo "  Rust: $RUST_VERSION"
              echo "new-release-version=$RUST_VERSION" >> $GITHUB_OUTPUT
              echo "new-release-published=true" >> $GITHUB_OUTPUT
            else
              echo "‚ÑπÔ∏è No new version (no releasable commits since last release)"
              echo "new-release-published=false" >> $GITHUB_OUTPUT
            fi
          fi

      - name: Update version in files
        if: steps.semantic.outputs.new-release-published == 'true'
        run: |
          # Read the converted versions
          PYTHON_VERSION=$(cat .next-version-python)
          RUST_VERSION=$(cat .next-version-rust)

          echo "Updating Python version to: $PYTHON_VERSION"
          echo "Updating Rust version to: $RUST_VERSION"

          # Update pyproject.toml with PEP 440 format
          sed -i "s/^version = .*/version = \"$PYTHON_VERSION\"/" priors/pyproject.toml

          # Update Cargo.toml with SemVer format
          sed -i "s/^version = .*/version = \"$RUST_VERSION\"/" priors/Cargo.toml

          echo "Updated files:"
          grep "^version" priors/pyproject.toml
          grep "^version" priors/Cargo.toml

      - name: Upload updated files
        if: steps.semantic.outputs.new-release-published == 'true'
        uses: actions/upload-artifact@v4
        with:
          name: version-files
          path: |
            priors/pyproject.toml
            priors/Cargo.toml

      - name: Debug outputs
        run: |
          echo "new-release-published: ${{ steps.semantic.outputs.new-release-published }}"
          echo "new-release-version: ${{ steps.semantic.outputs.new-release-version }}"

  build-python:
    name: Build & Publish Python to TestPyPI
    needs: semantic-release
    # Always run builds, regardless of whether we publish
    uses: ./.github/workflows/test-release.yml
    secrets: inherit
    with:
      version: ${{ needs.semantic-release.outputs.new-release-version }}
      # Only publish when manually triggered with checkbox enabled
      skip_publish: ${{ github.event_name != 'workflow_dispatch' || github.event.inputs.publish_to_testpypi != 'true' }}

  build-rust:
    name: Build Rust (Dry-Run)
    needs: semantic-release
    # Always run builds, regardless of whether we publish
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      - name: Download version files
        uses: actions/download-artifact@v4
        with:
          name: version-files
          path: priors

      - name: Install Rust
        uses: dtolnay/rust-toolchain@stable

      - name: Verify Cargo.toml version
        working-directory: priors
        run: |
          echo "Current Cargo.toml version:"
          grep "^version" Cargo.toml

      - name: Build Rust library
        working-directory: priors
        run: cargo build --release

      - name: Dry-run publish to crates.io
        working-directory: priors
        run: |
          echo "üîç Simulating crates.io publish (dry-run)..."
          cargo publish --dry-run --allow-dirty
